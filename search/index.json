[{"content":"一 SIMPLE算法概述 SIMPLE（Semi-Implicit Method for Pressure Linked Equations），全称压力耦合方程组半隐式求解方法，是一种针对不可压NS方程，通过数值上解耦速度和压力实现求解的算法，常常用于求解稳态流动问题。\n本文及后续SIMPLE系列文章来源于笔者近期的学习经历，介绍SIMPLE的基本实现和思路，并通过这一计算流体力学中经典的算法，窥见CFD求解中的部分基础思想和常见方法。\n二 SIMPLE算法理解 2.1 从简化到实际 我们以流体力学中经典的benchmark——二维Poiseuille流为例。考虑完全发展、定常的槽道流，动量方程可以写为： $$ \\frac{d}{dy}\\ ( \\mu\\frac{dU}{dy} )-P_x=0 $$ 该动量方程无比简洁，运用小学知识即可将其离散为一维的差分方程并直观地数值求解；为了更高的数值精度，也可采用半网格方法处理粘性系数。若考虑均匀粘性的层流情况，$ \\mu=cons.$，该方程甚至有经典的抛物线分布理论解。\n然而，若要考虑流动在整个管道中的分布，必须考虑流动入口处非均匀的速度、压力分布。此时，垂直于流动方向的速度是不可忽略的。完整的二维动量方程形如（忽略体积力）： $$ \\rho\\left(\\frac{\\partial u}{\\partial t}+u \\frac{\\partial u}{\\partial x}+v \\frac{\\partial u}{\\partial y}\\right)=-\\frac{\\partial p}{\\partial x}+\\frac{\\partial}{\\partial x}\\left(2 \\mu \\frac{\\partial u}{\\partial x}\\right)+\\frac{\\partial}{\\partial y}\\left[\\mu\\left(\\frac{\\partial u}{\\partial y}+\\frac{\\partial v}{\\partial x}\\right)\\right] $$$$ \\rho\\left(\\frac{\\partial v}{\\partial t}+u \\frac{\\partial v}{\\partial x}+v \\frac{\\partial v}{\\partial y}\\right)=-\\frac{\\partial p}{\\partial y}+\\frac{\\partial}{\\partial y}\\left(2 \\mu \\frac{\\partial u}{\\partial y}\\right)+\\frac{\\partial}{\\partial x}\\left[\\mu\\left(\\frac{\\partial u}{\\partial y}+\\frac{\\partial v}{\\partial x}\\right)\\right] $$其中压力$p=p(x,y)$。事实上，对于类似给定压力梯度的流动，压力可以写为类似于分离变量的形式： $$ p(x,y)=P_x x+p^*(x,y) $$ 带回动量方程可以发现，给定的压力梯度在这里处理为了一种动量方程的源项；事实上，OpenFOAM示例算例planarPoiseuille中便做了类似的处理来添加压力梯度（fvModels，semiImplicitSource）。$p^*(x,y)$的意义稍后会提到。\n另外有连续性方程来封闭方程组： $$ \\frac{\\partial u}{\\partial x}+\\frac{\\partial v}{\\partial y}=0 $$ 很容易发现，这三个方程中压力和速度是强耦合的，数值构造的难度与之前提到的一维问题天壤之别。究其原因，是引入了第二个方向后，需要同时考虑不均匀的压力分布和连续性方程。\n然而数学和自然是统一的。二者同时加入了封闭的系统，二者也必然能相互封闭，两难自解。\n2.2 以压力为媒：压力修正法 我们自然而然地想到：可不可以先求解动量方程，再让压力和连续性方程相互满足？\n这便是压力修正法的基本思路——先假定压力分布，求解动量方程得到预测速度，再反过头来求解压力，并修正速度，使得速度可以满足连续性方程。\n在流体力学中，有关压力的方程为泊松方程。事实上，压力泊松方程的推导形式与连续性方程极为相似，即对动量方程求散度，带入连续性条件得到： $$ \\nabla^2p=\\rho((\\frac{\\partial u}{\\partial x})^2+(\\frac{\\partial v}{\\partial y})^2+2\\frac{\\partial u}{\\partial y}\\frac{\\partial v}{\\partial x}) $$该方程的推导过程中，代入离散形式和预估变量，即可得到压力修正方程。压力修正方程的一般形式为： $$ \\nabla^2p=f(u) $$ 其中$f(u)$为源项，往往为预估速度的连续性误差。该部分内容会在后续文章中详细介绍。由此可见，方程的连续性在压力修正法中通过压力得到了体现；相较于连续性的零散度，多出来的速度散度，也即体积膨胀，通过压力“压缩”进行补偿。\n回到我们之前讨论的Poiseuille流问题：很显然，给定的压力梯度并不体现在修正方程中。可以不充分但不失一般性地认为，在求解这一问题过程中，相较于一维问题，二维问题引入的垂向速度在原有压力梯度的基础上引入了额外的压力分布，其正是压力修正的主角；也可以发现，独立于原有压力梯度，新引入的压力分布和垂向速度构成封闭和自洽，可以窥见压力修正法的基本思想。\n得到压力后，基于该压力值修正速度，进行迭代，即可获得同时满足连续性方程和动量方程的速度值。\n三 SIMPLE的基本流程 总结而言，SIMPLE算法在每一个迭代步内包含以下步骤：\n预测步：根据假定压力（或上一步压力）计算动量方程\n修正步：求解压力修正方程，修正压力和速度\n根据速度计算其他输运量\n整体程序实现如下框图所示：\n","date":"2025-06-20T00:00:00Z","image":"http://localhost:1313/p/simple1/cfd_hu_48bff1c43cba63b8.jpg","permalink":"http://localhost:1313/p/simple1/","title":"CFD算法 - SIMPLE(1)：基础思路"},{"content":"一 重叠网格概述 重叠网格（Overlapping grids），又名Chimera网格或嵌套网格（Overset grids），是一种用以处理复杂的网格运动和解决复杂几何体动网格问题的区域分割与网格组合策略。在该类方法中，网格被分为多个相互重叠嵌套的网格区域，其中贴体网格部分随网格运动，计算在各个网格区域上分别进行，各部分网格之间通过插值进行信息传递。\n重叠网格的实质，是通过局部重叠的方式将一套或多套贴体子网格与背景网格进行组装配合，生成一套网格并借助插值过程实现计算。在实际应用中，重叠网格方法包括网格生成、网格挖洞和装配和插值与计算三个主要步骤。本文将以该步骤为顺序，以OpenFOAM ESI版本中的重叠网格方法为例分别详细解释各个步骤的原理和实现。\n二 重叠网格流程 2.1 网格生成 重叠网格体系中，生成的网格主要包括以下两类：\n背景网格：用于定义计算域，设置网格背景和计算域边界条件\n组件网格：用于贴合内部壁面，设置壁面边界条件\n其中，在动网格情况下，组件网格随物体壁面运动而运动，背景网格静止。\n网格的生成已有多种成熟的技术。在OpenFOAM中，贴体网格的生成可以通过snappyHexMesh功能实现。分别生成两套网格后，网格通过mergeMeshes命令进行结合，而后可借助topoSet定义重叠区域。\n相关前处理流程：\n1 2 3 4 5 6 7 mergeMeshes -overwrite 组件网格 背景网格 cd 组件网格 checkMesh topoSet 这里值得注意的是，在使用多套重叠网格时，若某点有多层重叠，topoSet中regionToCell会优先选中region0，即mergeMeshes的第一个参数。该指定目前尚无自定义选项可以改变，而这一特性会影响topoSet对region的选定。需要仔细确认topoSet定义region的逻辑，从而确定mergeMeshes的参数顺序。\n2.2 网格挖洞和装配 2.2.1 初始网格中网格点分类 经过网格生成和组合的初始网格，其中的网格点被分为以下几类：\n洞内点：从计算网格中被剔除，不参与计算的点 插值点：位于重叠区域内，计算时需要从其他点插值获取流场信息的点 计算点：直接参与计算的点 其中，洞内点的产生是由于网格重叠后，部分网格位于计算边界外或被重复计算无需保留。剔除这一部分网格的过程被称为挖洞过程。在重叠网格的计算中，网格之间通过插值的方式相互传递信息，参与插值的点称为插值点；其余直接参与计算的点称为计算点。\nPeng L, Zhenxun G, Chongwen J. The progress of the overlapping grid techniques[J]. Mechanics in Engineering, 2014, 36(5): 551-565. 2.2.2 网格的挖洞和装配 网格的装配过程，实质上是建立网格之间插值通信关系的过程。该部分的细节会在后续章节中详细介绍。\n以OpenFOAM ESI v2212中教程算例twoSimpleRotors为例，说明重叠网格计算中挖洞和网格装配过程。OpenFOAM以cellType变量标识上述网格类型，其中0对应计算网格，1对应插值网格，2对应洞内网格。\n上图中分别展示了组件网格和背景网格的挖洞和插值网格分布情况。可见在背景网格中，以组件网格壁面向外拓展的一部分网格被挖洞，洞边界上的网格中变量信息由插值得到；对于组件网格，其与背景网格的重叠边界上的信息由背景网格向其插值得到。\n2.3 插值与计算 组件网格和背景网格之间的插值实现方法较多。OpenFOAM中，主要使用的格式包括基于网格距离的inverse distance方法和基于网格之间重叠体积关系的Cell Volume Weight方法。\n2.3.1 Inverse Distance 该方法基本思路是以贡献网格（Donor）和被插值网格（acceptor）之间的距离为基础加权插值。\n对于图中情况，各个贡献网格的权重表示为： $$ \\omega_i=\\frac{1/|d_i|}{S} $$其中$S$为距离绝对值倒数之和： $$ S=\\Sigma\\frac{1}{|d_i|} $$ 被插值网格上插值变量$\\phi$由是表示为： $$ \\phi_{a}=\\Sigma \\omega_i \\phi_i $$ 该方法具有二阶精度，但无法保证守恒。\nOpenFOAM中使用Inverse Distance计算权重的函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 void Foam::cellCellStencils::inverseDistance::stencilWeights ( const point\u0026amp; sample, const pointList\u0026amp; donorCcs, scalarList\u0026amp; weights ) const { // Inverse-distance weighting weights.setSize(donorCcs.size()); scalar sum = 0; forAll(donorCcs, i) { const scalar d = mag(sample-donorCcs[i]); if (d \u0026gt; ROOTVSMALL) { weights[i] = scalar(1)/d; sum += weights[i]; } else { // Short circuit weights = scalar(0); weights[i] = scalar(1); return; } } forAll(weights, i) { weights[i] /= sum; } } 2.3.2 Cell Volume Weight 该方法基于源网格单元与目标单元相交部分的体积比例确定插值权重。加权过程与Inverse Distance类似，权重函数表示为： $$ \\omega_i=\\frac{V^o_i}{V_a} $$ 其中，$V_i^o$为贡献网格与被插值网格重叠的体积，$V_a$为被插值网格总体积。\n相较于Inverse Distance，该类方法能够保证质量守恒（$\\Sigma \\omega_i=1$），但是计算消耗和复杂度都较高，并且仅具有一阶精度。\n三 OpenFOAM 重叠网格计算流程 以下伪代码说明OpenFOAM中计算重叠网格的流程，引用修改自Wang, Dongxu, and Sheng Dong, OE2023\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Start the PIMPLE outer loop Solve structure motion equation Update the mesh (and cell stencil) as per the structure motion Solve the VOF equation (isoAdvector with the source added, see Subsection 2.2) Construct the velocity coefficient matrix (the momentum predictor is not performed) Start the PIMPLE inner loop Solve the pressure Possion equation (solve prgh from the governing equation) Update the velocity and pressure fields explicitly End the PIMPLE inner loop if converged Solve the turbulence equation if the present outer loop is the last loop End the PIMPLE outer loop if converged or the maximum outer loop number is reached End the current time step, and then enter the next time step ","date":"2025-05-31T00:00:00Z","image":"http://localhost:1313/p/oversetgrid/cfd_mesh_hu_6b09c4704ad55f3c.jpg","permalink":"http://localhost:1313/p/oversetgrid/","title":"CFD算法 - 重叠网格技术"},{"content":"正文测试 文字测试 这是一段文字\n数学公式测试 Navier-Stokes方程: $$ \\rho(\\frac{\\partial \\bold{U}}{\\partial t}+\\bold{U}\\cdot\\nabla\\bold{U})=-\\nabla P+\\rho \\bold{g}+\\bold{f} $$ 其中$\\bold{g}$为重力加速度，$\\bold{f}$为体积力。\n代码插入测试 下面是OpenFOAM9中pimpleFoam求解器速度方程求解代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 MRF.correctBoundaryVelocity(U); tmp\u0026lt;fvVectorMatrix\u0026gt; tUEqn ( fvm::ddt(U) + fvm::div(phi, U) + MRF.DDt(U) + turbulence-\u0026gt;divDevSigma(U) == fvModels.source(U) ); fvVectorMatrix\u0026amp; UEqn = tUEqn.ref(); UEqn.relax(); fvConstraints.constrain(UEqn); if (pimple.momentumPredictor()) { solve(UEqn == -fvc::grad(p)); fvConstraints.constrain(U); } 引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"http://localhost:1313/p/test-chinese/","title":"综合测试"}]